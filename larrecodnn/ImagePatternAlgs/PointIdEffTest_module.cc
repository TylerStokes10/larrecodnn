////////////////////////////////////////////////////////////////////////
// Class:       PointIdEffTest
// Module Type: analyzer
// File:        PointIdEffTest_module.cc
//
// Generated at Fri Apr 29 06:42:27 2016 by Dorota Stefan using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "larsim/Simulation/SimChannel.h"
#include "larsim/Simulation/LArG4Parameters.h"
#include "larcore/Geometry/Geometry.h"
#include "larcore/Geometry/GeometryCore.h"
#include "lardata/RecoBase/Hit.h"
#include "lardata/RecoBase/Cluster.h"
#include "lardata/RecoBase/Track.h"
#include "lardata/RecoBase/Vertex.h"
#include "lardata/RecoBase/Shower.h"
#include "lardata/AnalysisAlg/CalorimetryAlg.h"
#include "SimulationBase/MCParticle.h"
#include "SimulationBase/MCTruth.h"
#include "larcore/SimpleTypesAndConstants/PhysicalConstants.h"
#include "lardata/Utilities/DatabaseUtil.h"

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "TH1.h"
#include "TTree.h"
#include "TLorentzVector.h"
#include "TVector3.h"

#include <cmath>

namespace nnet
{
	class PointIdEffTest;
}

class nnet::PointIdEffTest : public art::EDAnalyzer {
public:
  explicit PointIdEffTest(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  PointIdEffTest(PointIdEffTest const &) = delete;
  PointIdEffTest(PointIdEffTest &&) = delete;
  PointIdEffTest & operator = (PointIdEffTest const &) = delete;
  PointIdEffTest & operator = (PointIdEffTest &&) = delete;

  // Required functions.
	void beginRun(const art::Run& run) override;

	void beginJob() override;

  void analyze(art::Event const & e) override;

	void reconfigure(fhicl::ParameterSet const& parameterSet) override;


private:

  // Declare member data here.

	void GetMCParticle(art::Event const & e, float fraction, int pdg);

	void GetRecoParticle();

	void TestEffParticle();

	int fRun;
	int fEvent;

	double fElectronsToGeV;
	int fSimTrackID;
	int fSimPDG;

	TH1D* fHist;

	TTree *fTree;

	std::map< int, const simb::MCParticle* > particleMap;

	std::vector< art::Ptr<sim::SimChannel> > fChannellist;
	std::vector< art::Ptr<simb::MCParticle> > fSimlist;
	std::vector< art::Ptr<recob::Hit> > fHitlist;
	std::vector< art::Ptr<recob::Cluster> > fClusterlist;


	std::string fSimulationProducerLabel;
	std::string fHitsModuleLabel;
	std::string fClusterModuleLabel;
};

void nnet::PointIdEffTest::reconfigure(fhicl::ParameterSet const & p)
{
	fSimulationProducerLabel = p.get< std::string >("SimModuleLabel");
	fHitsModuleLabel = p.get< std::string >("HitsModuleLabel");
	fClusterModuleLabel = p.get< std::string >("ClusterModuleLabel");
}


nnet::PointIdEffTest::PointIdEffTest(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{}

void nnet::PointIdEffTest::beginRun(const art::Run&)
{
	art::ServiceHandle< sim::LArG4Parameters > larParameters;
	fElectronsToGeV = 1./larParameters->GeVToElectrons();
}

void nnet::PointIdEffTest::beginJob()
{
	// access art's TFileService, which will handle creating and writing hists
	art::ServiceHandle<art::TFileService> tfs;

	fHist = tfs->make<TH1D>("efficiency-purity",";efficiency-purity;",100, 0.,    0.);

	fTree = tfs->make<TTree>("efficiency","efficiency tree");
	// fTree->Branch("fEkinreco", &fEkinreco, "fEkinreco/D");
}

void nnet::PointIdEffTest::analyze(art::Event const & e)
{
  // Implementation of required member function here.

	fRun = e.run();
	fEvent = e.id().event();
	fSimTrackID = -1; fSimPDG = -1;

	// access to MC information
	
	// MC Particle

	art::Handle< std::vector<simb::MCParticle> > particleHandle;
	if (e.getByLabel(fSimulationProducerLabel, particleHandle))
		art::fill_ptr_vector(fSimlist, particleHandle);
	
	
	for ( auto const& particle : (*particleHandle) )
	{
		fSimTrackID = particle.TrackId();
		particleMap[fSimTrackID] = &particle;

		fSimPDG = particle.PdgCode();
	}

	// simChannel


	// output from reconstruction



	// cluster
	art::Handle< std::vector<recob::Cluster> > clusterListHandle;
	if (e.getByLabel(fClusterModuleLabel, clusterListHandle))
		art::fill_ptr_vector(fClusterlist, clusterListHandle);
	
}

/// w argumencie podamy wektor hitow danego klastra
void nnet::PointIdEffTest::GetMCParticle(art::Event const & e, float fraction, int pdg )
{
	// in argument vector hitow danego klastra

	double ensh = 0.; double entrk = 0.;
	int nhitssh = 0; int nhitstrk = 0;

	art::Handle< std::vector<simb::MCParticle> > particleHandle;
	if (e.getByLabel(fSimulationProducerLabel, particleHandle))
		art::fill_ptr_vector(fSimlist, particleHandle);

		art::Handle< std::vector<sim::SimChannel> > simChannelHandle;
	if (e.getByLabel(fSimulationProducerLabel, simChannelHandle))
		art::fill_ptr_vector(fChannellist, simChannelHandle);


	// hits
	art::Handle< std::vector<recob::Hit> > hitListHandle;
	if (e.getByLabel(fHitsModuleLabel, hitListHandle))
		art::fill_ptr_vector(fHitlist, hitListHandle);

	// for every hit:
	for ( auto const& hit : (*hitListHandle) )
	{
		// the channel associated with this hit.
		auto hitChannelNumber = hit.Channel();

		for ( auto const& channel : (*simChannelHandle) )
		{
			auto simChannelNumber = channel.Channel();

			if ( simChannelNumber != hitChannelNumber ) continue;

			// for every time slice in this channel:
			auto const& timeSlices = channel.TDCIDEMap();
			for ( auto const& timeSlice : timeSlices )
			{
				int time = timeSlice.first;
				if ( std::abs(hit.TimeDistanceAsRMS(time) ) < 1.0 )
				{

					// loop over the energy deposits.
					auto const& energyDeposits = timeSlice.second;
		
					for ( auto const& energyDeposit : energyDeposits )
					{
						auto search = particleMap.find( energyDeposit.trackID );
						if ( search == particleMap.end() ) continue;
						int trackID = (*search).first;

						const simb::MCParticle& particle = *((*search).second);
						double energy = energyDeposit.numElectrons * fElectronsToGeV;
						// test it is shower type	
						if ( (trackID < 0) && (particle.PdgCode() == pdg) )
						{
							ensh += energy;
							nhitssh++;
						}
						else
						{
							entrk += energy;
							nhitstrk++;
						}

					}		
				}
			}
		}
	}
}

void nnet::PointIdEffTest::GetRecoParticle()
{
}

void nnet::PointIdEffTest::TestEffParticle()
{
}


DEFINE_ART_MODULE(nnet::PointIdEffTest)
