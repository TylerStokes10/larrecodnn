

////////////////////////////////////////////////////////////////////////
//
// StitchAlg.cxx
//
// echurch@fnal.gov
//
// This alg is called by TrackStich_module.cc in order to stitch together
// tracks which point at each other and have gaps to within user-set
// tolerances.
////////////////////////////////////////////////////////////////////////


#include <boost/bind.hpp>

//Framework includes:
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

//#include <TStopwatch.h>

#include "StitchAlg.h"
#include "fhiclcpp/ParameterSet.h" 
#include "art/Persistency/Common/Ptr.h" 
#include "art/Persistency/Common/PtrVector.h" 
#include "art/Framework/Services/Registry/ServiceHandle.h" 
#include "messagefacility/MessageLogger/MessageLogger.h" 
#include "CLHEP/Random/RandFlat.h"
#include "Utilities/LArProperties.h"
#include "Utilities/DetectorProperties.h"
#include "RecoAlg/fuzzyClusterAlg.h"
#include "RecoBase/Hit.h"
#include "Geometry/PlaneGeo.h"
#include "Geometry/WireGeo.h"
#include "Utilities/AssociationUtil.h"

#include <time.h>
#include <cmath>
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <vector>

trkf::StitchAlg::StitchAlg(fhicl::ParameterSet const& pset) 
{
  ftNo = 0;
  ftListHandle.clear();
 this->reconfigure(pset); 
 fTrackVec.clear();
 fTrackComposite.clear();
}

//----------------------------------------------------------

//----------------------------------------------------------
void trkf::StitchAlg::reconfigure(fhicl::ParameterSet const& pset)
{

  fCosAngTol           = pset.get< double >("CosAngTolerance", 0.95); 
  fSepTol              = pset.get< double >("SpptSepTolerance", 10.0); //cm 
}


void trkf::StitchAlg::FindHeadsAndTails( const art::Event& EvtArg, const std::string& trackModuleLabelArg  )
{

  EvtArg.getByLabel(trackModuleLabelArg,ftListHandle);

    // An element of fh and ft for each outer track. Keep the cos and sep parameters of the match and a string that indicates whether it's the second track's head or tail that gives the match, along with ii, jj, the indices of the outer and inner tracks.
    ft.clear(); 
    fh.clear();

    int ntrack = ftListHandle->size();
    //    std::cout << "StitchAlg.FindHeadsAndTails: Number of tracks in " << ntrack << std::endl;
    for(int ii = 0; ii < ntrack; ++ii) {
      art::Ptr<recob::Track> ptrack1(ftListHandle, ii);
      const recob::Track& track1 = *ptrack1;
      const TVector3 start1(track1.Vertex());
      const TVector3 end1(track1.End());
      const TVector3 start1Dir(track1.VertexDirection());
      const TVector3 end1Dir(track1.EndDirection());
    // For each outer track, make a vector of 1 candidate track. Doesn't need to be a vector except for desire to have a 2-iteration history.
      std::vector< std::tuple< std::string, int, int, double, double> > headvv;
      std::vector< std::tuple< std::string, int, int, double, double> > tailvv;
      
      // For head/tail keep a vector of candidate (cos,sep)
      std::vector< std::vector<std::pair< double, double>> > matchhead;
      std::vector< std::vector<std::pair< double, double>> > matchtail;
      // Neither end of track1 is yet matched:
      bool head(false);
      bool tail(false);
      std::vector<art::Ptr <recob::Track> >::iterator ith, itt;

      for(int jj = ii+1; jj < ntrack; ++jj) {
	art::Ptr<recob::Track> ptrack2(ftListHandle, jj);
	const recob::Track& track2 = *ptrack2;
	const TVector3& start2(track2.Vertex());
	const TVector3& end2(track2.End());
	const TVector3& start2Dir(track2.VertexDirection());
	const TVector3& end2Dir(track2.EndDirection());
	std::string sHT2("NA"); // track2 (receptor track) H or T is tagged as matched


	bool c12((std::abs(start1Dir.Dot(end2Dir))>fCosAngTol) && ((start1-end2).Mag()<fSepTol));
	bool c21((std::abs(end1Dir.Dot(start2Dir))>fCosAngTol) && ((start2-end1).Mag()<fSepTol));
	bool c11((std::abs(start1Dir.Dot(start2Dir))>fCosAngTol) && ((start1-start2).Mag()<fSepTol));
	bool c22((std::abs(end1Dir.Dot(end2Dir))>fCosAngTol) &&  ((end1-end2).Mag()<fSepTol));

	if ( c12 || c21 || c11 || c22 )
	  {

	    sHT2 = "NA";
	    if (c12||c11) head=true; if (c11) sHT2 = "H"; else if (c12) sHT2 = "T";
	    if (c21||c22) tail=true; if (c21) sHT2 = "H"; else if (c22) sHT2 = "T";

	    if (head && tail) // split the tie by distance
	      { 
		head = false; tail = false;
		if ( ((start1-end2).Mag() < (start2-end1).Mag()) || ((start1-end2).Mag() < (start2-end2).Mag()) || ((start1-start2).Mag() < (start2-end1).Mag()) || ((start1-start2).Mag() < (start2-end2).Mag()) )
		  { head = true; tail = false; }
		else
		  { head = false; tail = true; }
	      }

	    if (head) 
	      {
		// 2-deep vector, for head and tail of 2nd track
		std::vector< std::pair <double,double> > headv;
		headv.push_back(std::pair<double,double>(abs(start1Dir.Dot(start2Dir)), (start1-start2).Mag()) );
		headv.push_back(std::pair<double,double>(abs(start1Dir.Dot(end2Dir)), (start1-end2).Mag()) );

		matchhead.push_back( headv );
		// if inferior, drop the new elements; if superior, replace the old
		if ( ((matchhead.size() > 1) && ( (matchhead.back().at(0).second < matchhead.front().at(0).second) || (matchhead.back().at(1).second < matchhead.front().at(1).second ) ) ) || matchhead.size()==1 )
		  {
		    if (matchhead.size()>1) matchhead.erase(matchhead.begin());
		    if (headvv.size()>1) headvv.erase(headvv.begin());
		    if (!sHT2.compare("H"))
		      {
			auto tupTmp =std::make_tuple(sHT2,ii,jj,matchhead.back().at(0).first,matchhead.back().at(0).second);
			headvv.push_back (tupTmp);
		      }
		    else
		      {
			auto tupTmp = std::make_tuple(sHT2,ii,jj,matchhead.back().at(1).first,matchhead.back().at(1).second);
			headvv.push_back (tupTmp);
		      }
		  }
		else 
		    matchhead.pop_back();

		  

	        std::cout << "TrackStitcher: satisfied head. " << std::endl;
	      } // head
		 
	    else if (tail) // else if to prevent same stitching candidate being 
		               // allowed at both head and tail
	      {
		// 2-deep vector, for head and tail of 2nd track
		std::vector< std::pair <double,double> > tailv;
		tailv.push_back(std::pair<double,double>( abs(end1Dir.Dot(start2Dir)),(start2-end1).Mag() ) );
		tailv.push_back(std::pair<double,double>( abs(end1Dir.Dot(end2Dir)),(end1-end2).Mag() ) );
		matchtail.push_back( tailv );
		// if inferior, drop the new elements; if superior, replace the old
		if ( ((matchtail.size() > 1) && ( (matchtail.back().at(0).second < matchtail.front().at(0).second) || (matchtail.back().at(1).second < matchtail.front().at(1).second ) ) ) || matchtail.size()==1 )
		  {
		    if (matchtail.size()>1) matchtail.erase(matchtail.begin());
		    if (tailvv.size()>1) tailvv.erase(tailvv.begin());
		    if (!sHT2.compare("T"))
		      {
			auto tupTmp = std::make_tuple(sHT2,ii,jj,matchtail.back().at(0).first,matchtail.back().at(0).second);
			tailvv.push_back(tupTmp);
		      }
		    else
		      {
			auto tupTmp = std::make_tuple(sHT2,ii,jj,matchtail.back().at(1).first,matchtail.back().at(1).second);
			tailvv.push_back(tupTmp);
		      }
		  }
		else 
		  matchtail.pop_back();

		std::cout << "TrackStitcher: satisfied tail. " << std::endl;
	      } //tail

	    std::cout << "abs(start1Dir.Dot(end2Dir)) " << std::abs(start1Dir.Dot(end2Dir)) << ", start1-end2.Mag(): " << (start1-end2).Mag() << std::endl;
	    std::cout << "abs(end1Dir.Dot(start2Dir)) " << std::abs(end1Dir.Dot(start2Dir)) << ", start2-end1.Mag(): " << (start2-end1).Mag() << std::endl;
	    std::cout << "abs(start1Dir.Dot(start2Dir)) " << std::abs(start1Dir.Dot(start2Dir)) << ", start1-start2.Mag(): " << (start1-start2).Mag() << std::endl;
	    std::cout << "abs(end1Dir.Dot(end2Dir)) " << std::abs(end1Dir.Dot(end2Dir)) << ", end1-end2.Mag(): " << (end1-end2).Mag() << std::endl;
	    std::cout << "sHT2 " << sHT2 << std::endl;	    

	  } // end c11||c12||c21||c22

	// We've been careful to pick the best jj match for this iith track head and tail.
	// Now we need to be sure that for the jjth track head/tail we don't have two ii trks.
	if (headvv.size())
	  {
	    int otrk = std::get<2>(headvv.back()); // jj'th track for this iith trk
	    // H or T of this jj'th trk we're matched to.
	    std::string sotrkht(std::get<0>(headvv.back()));
	    for (int kk=0;kk<ii;++kk)
	      {
		if (std::get<2>(fh.at(kk)) == otrk && !sotrkht.compare(std::get<0>(fh.at(kk)) ) )
		  {
		    // check matching sep and pick the best one. Either erase this
		    // headvv (and it'll get null settings later below) or null out 
		    // the parameters in fh.
		    if (std::get<4>(headvv.back()) < std::get<4>(fh.at(kk)) && std::get<4>(headvv.back())!=0.0)
		      {
			if (ii==5 && jj==7)
			  {
			    std::cout << "StitchAlg::  debug ------  ii==13 && jj==14"<< std::endl;
			  }
			auto tupTmp2 = std::make_tuple(std::string("NA"),kk,-12,0.0,0.0);
			fh.at(kk) = tupTmp2;
		      }
		    else if (std::get<4>(headvv.back())!=0.0)
		      {
			headvv.pop_back();
			break;
		      }
		  }
	      }
	  }
	if (tailvv.size())
	  {
	    int otrk = std::get<2>(tailvv.back());  // jj'th track for this iith trk
	    // H or T of this jj'th trk we're matched to.
	    std::string sotrkht(std::get<0>(tailvv.back()));
	    for (int kk=0;kk<ii;++kk)
	      {
		if (std::get<2>(ft.at(kk)) == otrk && !sotrkht.compare(std::get<0>(ft.at(kk)) ) )
		  {
		    // check matching sep and pick the best one. erase either this
		    // tailvv or null out the parameters in ft.
		    if (std::get<4>(tailvv.back()) < std::get<4>(ft.at(kk)) && std::get<4>(tailvv.back())!=0.0)
		      {
			if (ii==13 && jj==14)
			  {
			    std::cout << "StitchAlg::  debug ------  ii==13 && jj==14"<< std::endl;
			  }
			auto tupTmp2 = std::make_tuple(std::string("NA"),kk,-12,0.0,0.0);
			ft.at(kk) = tupTmp2;
		      }
		    else if (std::get<4>(tailvv.back())!=0.0)
		      {
			tailvv.pop_back();
			break;
		      }
		  }
	      }
	  }


      } // jj
      
      
      auto tupTmp2 = std::make_tuple(std::string("NA"),ii,-12,0.0,0.0);
      // We always have our best 1-element tailvv and headvv for trk o at this point
      if (!headvv.size()) headvv.push_back(tupTmp2);
      if (!tailvv.size()) tailvv.push_back(tupTmp2);
      std::cout << "StitchAlg::FindHeadsAndTails: headvv, tailvv .get<0> is " << std::get<0>(headvv.back()) << ", " << std::get<0>(tailvv.back()) << std::endl;
      fh.push_back(headvv.back());
      ft.push_back(tailvv.back());
    
    } // ii

    //    std::cout << "fh.size, ft.size are " << fh.size() << ", " << ft.size() << std::endl;

}

void trkf::StitchAlg::Stitch()
{    
    // take the vector of tracks, walk through each track's vectors of xyz, dxdydz, etc 
    // and concatenate them into longer vectors. Use those to instantiate one new 
    // Stitched-together track.
    std::vector<TVector3> xyz;
    std::vector<TVector3> dxdydz;
    std::vector<TMatrixT<double> > cov;
    std::vector<double> mom;
    std::vector< std::vector <double> > dQdx;
    //art::PtrVector<recob::Track>::const_iterator
    size_t cnt(0);
    for (auto it = fTrackComposite.back().begin(); it!=fTrackComposite.back().end(); ++it)
      {
	cnt++;
	for (size_t pt = 0; pt!=(*it).get()->NumberTrajectoryPoints(); pt++)
	  {
	    size_t ptHere(pt);
	    // ask if 2nd character of 2-character string is an H. If so, reverse order
	    // of the concatenation.
	    if (!fHT.back().at(cnt-1).compare(1,1,"H")) 
	      ptHere = (*it).get()->NumberTrajectoryPoints() - pt;
	    try 
	      { 
		xyz.push_back((*it).get()->LocationAtPoint(ptHere));
		std::cout << "Stitching track number " << cnt << " with TrajPt at ptHere " << ptHere << " at x,y,z: " << xyz.back().X() << ", " << xyz.back().Y() << ", " << xyz.back().Z() << std::endl;
		dxdydz.push_back((*it).get()->DirectionAtPoint(ptHere));
		TMatrixT<double>  dumc(5,5); 
		if (ptHere<(*it).get()->NumberCovariance())
		  dumc = (*it).get()->CovarianceAtPoint(ptHere);
		cov.push_back(dumc);
		double dumm(0.0); 
		if (ptHere<(*it).get()->NumberFitMomentum())
		  dumm = (*it).get()->MomentumAtPoint(ptHere);
		mom.push_back(dumm);
		std::vector <double> dum; 
		if (ptHere<(*it).get()->NumberdQdx(geo::kZ))
		  dum.push_back((*it).get()->DQdxAtPoint(ptHere,geo::kZ));
		else
		  dum.push_back(0.0);
		dQdx.push_back(dum);

	      }
	    catch (cet::exception &e)
	      {
		mf::LogVerbatim("TrackStitcher bailing. ") << " One or more of xyz, dxdydz, cov, mom, dQdx elements from original Track is out of range..." << e.what() << __LINE__;
		break;
	      }
	  }
      }
   
    /// TODO: sort according to spacepoint distance separation.
    /// As is, we're not sure we're not forming a stitched track with a (some) 
    /// jump(s) and a reversal(s) of direction in it.

    const recob::Track t(xyz,dxdydz,cov,dQdx,mom,ftNo++);
    //const art::Ptr<recob::Track> t(xyz,dxdydz,cov,dQdx,mom,ftNo++);
    fTrackVec.push_back(t);

}

void trkf::StitchAlg::Stizatch()
{

    art::PtrVector<recob::Track> compTrack;
    std::vector <std::string> trackStatus (fh.size(),"NotDone"); // H or T 
    std::vector <std::string> HT2 (fh.size(),"NA"); // H or T 


    for (unsigned int ii=0; ii<fh.size(); ++ii) // same as t.size()

      {
	if (!trackStatus.at(ii).compare("Done")) continue;

	const art::Ptr<recob::Track> th(ftListHandle, ii);
	compTrack.push_back(th);
	// Should there not be an HT.push_back here??

	// start with track 1: see if head goes anywhere, walk with it. Add to compTrack.
	//                     see if tail goes anywhere, walk with it. Insert to compTrack.
	// Go until the other tuple's other vtx string says "NA." Then change status string 
	// of vtxsJoined to "Done" for that track.
	assert (std::get<1>(fh.at(ii))==ii && std::get<1>(ft.at(ii))==ii && "Head or Tail index from std::tuple is not in agreement with track count");
	
	bool chain(true), firstTraj(true);
	int walk(ii);
	while (chain)
	  {
	    std::string sh(std::get<0>(fh.at(walk)));
	    std::string st(std::get<0>(ft.at(walk)));
	    int hInd = -12; 
	    int tInd = -12;

	    std::cout << "StichAlg::Stizatch(): Inside chain. walk(track), sh, st, " << walk << ", " << sh << ", "<<st <<", connected to tracks: " << std::get<2>(fh.at(walk))<<", "  << std::get<2>(ft.at(walk)) <<std::endl;
	    if (!sh.compare("H") || !sh.compare("T"))
	      {

		hInd = std::get<2>(fh.at(walk)); // index of track that walk is connected to.
		std::cout << "Stizatch(): hInd is " << hInd << std::endl;

		if (firstTraj)
		  {
		    const art::Ptr<recob::Track> th2( ftListHandle, hInd );
		    compTrack.push_back(th2);
		    HT2.push_back("H"+sh);
		  } // Don't do above again on second trip through here.
	      }

	    if ((!st.compare("H") || !st.compare("T")) && firstTraj)
	      {
		tInd = std::get<2>(ft.at(walk));
		std::cout << "Stizatch(): tInd is " << tInd << std::endl;
		const art::Ptr<recob::Track> th2( ftListHandle, tInd );
		compTrack.insert(compTrack.begin(),th2);
		HT2.insert(HT2.begin(),st+"T"); // since we will eventually read from 0th element forward
	      }
	    if (hInd!=-12) walk = hInd;
	    if (tInd!=-12) walk = tInd;
	    if (!sh.compare("NA") && !st.compare("NA")) 
	      {
		// It is possible that our first (ii'th) track had a head _and_ a tail match. Note,
		// that that would cause us to walk through its tail connections. Thus, we must ask 
		// again now if that track had both match and set firstTraj false if so ....
		if (!firstTraj) chain = false;
		firstTraj=false;
		walk = ii; 
	      }
	    trackStatus.at(walk) = "Done";
	  } // while

	// inside Stitch() push_back onto the vec<vec> of components and the vec of stitched composite.
	if (compTrack.size()) 
	  {
	    fTrackComposite.push_back(compTrack);
	    fHT.push_back(HT2);
	    std::cout << "Stizatch:: calling Stitch(). fTrackComposite.size(), fHT.size()" << fTrackComposite.size()<< ", " << fHT.size()  << std::endl;
	    Stitch(); // ptrVec trks, string HeadOrTail
	  }
	compTrack.clear();

      } // end ii loop on head/tail vector of tuples.

}

